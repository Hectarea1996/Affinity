<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Guide.html</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>

</head>

<body>

<h1 id="the-more-cffi-guide">The more-cffi guide</h1>
<h2 id="dealing-with-this-guide">Dealing with this guide</h2>
<p>This project extends the functionality of cffi in a very specific way. In fact, some other functionality like complex types translation is not used. Imagine that you need to create the translation of a complex structure and you use list or whatever. Each time you receive or use that object a translation needs to be done and maybe you only have used one or two members. That is one of the main reasons I’ve created this project. Using more-cffi the user of your projects will use raw pointers almost all the time (they will not note it) and the translations are made per-member and not per-object.</p>
<p>I was making this project as it goes. I think you can solve right now almost every problem that can show up when facing with C code. Despite that, I created this guide to explain how to avoid that problems at the same time I show how to use more-cffi.</p>
<p>Let’s start!</p>
<h2 id="dealing-with-documentation">Dealing with documentation</h2>
<p>The first you should know is that more-cffi can write some documentation automatically. Usually a C library has already its own documentation so you only need to tell the user how a function or a struct looks like in Common Lisp. Each macro that defines a struct or a function will gather the information you provide and write it in a formatted way. The default output format is markdown (GitHub markdow), although it can be changed.</p>
<p>When creating a project, it is usual to have multiple files where to write the bindings. Using more-cffi, each file would be one documentation page. That file could look like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>(<span class="kw">in-package</span> :my-pkg)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>(mcffi:with-doc-file (doc-file <span class="st">&quot;path/to/file.md&quot;</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="co">;; more-cffi stuff here...</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  )</span></code></pre></div>
<p>Using <code>with-doc-file</code> We specify a stream where to store the documentation. You can create your own streams using whatever you want, but more-cffi exports the <code>with-doc-file</code> macro. It is like <code>with-open-file</code> but simpler. In this example a symbol <code>doc-file</code> is bound to the file placed at <code>path/to/file.md</code>. Well, it would do that if we enable the generation. By default, the documentation generation is disabled and all the macros exported by more-cffi will only define their things without writing anything. We don’t want the documentation to be generated every time the project is loaded.</p>
<p>When your project is ready to load, you can generate the documentation changing the value of <code>*doc-generation*</code> that defaults to <code>nil</code>. First, load more-cffi:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>CL-USER&gt; (asdf:load-system :more-cffi)</span></code></pre></div>
<p>Now the symbol <code>*doc-generation*</code> is exported. Now load your project with its value set to any non-<code>nil</code> value:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>CL-USER&gt; (<span class="kw">let</span> ((mcffi:*doc-generation* <span class="kw">t</span>))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>           (asdf:load-system :my-project :force <span class="kw">t</span>)) <span class="co">; :force is important!</span></span></code></pre></div>
<p>Make sure that all your files are processed using the <code>:force</code> option. After this, all the documentation is generated. Each time you do this, the documentation is regenerated.</p>
<h2 id="dealing-with-your-project-structure">Dealing with your project structure</h2>
<p>In this guide I will use as example a little portion of the <a href="https://github.com/Hectarea1996/common-vulkan">Common Vulkan</a> project. The Vulkan library has a lot of different situations that can be problematic if we don’t do the right things. The main directories of Common Vulkan are <code>vulkan/</code> and <code>src/</code>. In the former we will write the cffi bindings. And in the latter we will use more-cffi to write the wrappers and documentation.</p>
<h2 id="dealing-with-cffi-bindings">Dealing with cffi bindings</h2>
<p>I won’t explain how cffi works so this will be short. In the <code>vulkan/</code> directory we encounter three files: <em>. <code>cfunctions.lisp</code>: Where function bindings are placed. </em>. <code>ctypes.lisp</code>: Where all structs, unions, typedefs… are placed. *. <code>load-vulkan.lisp</code>: Where the foreign library is loaded.</p>
<p>The third file is the first that we need to load. We need to use <code>define-foreign-library</code>. It should look like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>(cffi:define-foreign-library vulkan-loader</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  (:linux <span class="st">&quot;libvulkan.so.1&quot;</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  (:darwin <span class="st">&quot;libvulkan.1.dylib&quot;</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>  (:windows <span class="st">&quot;vulkan-1.dll&quot;</span>))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>(cffi:use-foreign-library vulkan-loader)</span></code></pre></div>
<p>Now we are ready to define the cffi bindings. As I said, in <code>cfunction.lisp</code> we can see the raw function bindings. They look like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>(more-cffi:defcfun (<span class="st">&quot;vkCreateInstance&quot;</span> vkcreateinstance</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>                    funcall-vkcreateinstance)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    vkresult</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>  (pcreateinfo :pointer)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>  (pallocator :pointer)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>  (pinstance :pointer))</span></code></pre></div>
<p>Or this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>(more-cffi:defcfun (<span class="st">&quot;vkGetPhysicalDeviceImageFormatProperties&quot;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>                    vkgetphysicaldeviceimageformatproperties</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>                    funcall-vkgetphysicaldeviceimageformatproperties)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    vkresult</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>  (physicaldevice vkphysicaldevice)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>  (<span class="kw">format</span> vkformat)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>  (<span class="kw">type</span> vkimagetype)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>  (tiling vkimagetiling)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>  (usage vkimageusageflags)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>  (flags vkimagecreateflags)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>  (pimageformatproperties :pointer))</span></code></pre></div>
<p>Note that we are using here the <code>defcfun</code> symbol from the more-cffi package. We will see how to use this later. The last file in this directory is <code>ctypes.lisp</code> where are stored all the type bindings. We can see typedefs:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>(cffi:defctype vkbool32 :uint32)</span></code></pre></div>
<p>Structs:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>(cffi:defcstruct vkbuffermemorybarrier</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  (stype vkstructuretype)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  (pnext :pointer)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  (srcaccessmask vkaccessflags)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>  (dstaccessmask vkaccessflags)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>  (srcqueuefamilyindex :uint32)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>  (dstqueuefamilyindex :uint32)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>  (buffer vkbuffer)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>  (offset vkdevicesize)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>  (size vkdevicesize))</span></code></pre></div>
<p>And unions too:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>(cffi:defcunion vkaccelerationstructuregeometrydatakhr</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  (triangles (:struct vkaccelerationstructuregeometrytrianglesdatakhr))</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  (aabbs (:struct vkaccelerationstructuregeometryaabbsdatakhr))</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>  (instances (:struct vkaccelerationstructuregeometryinstancesdatakhr)))</span></code></pre></div>
<p>Writing the raw bindings is the first step to create our project. Once this is done we can start creating the wrappers and documentation.</p>
<h2 id="dealing-with-more-cffi">Dealing with more-cffi</h2>
<p>Let’s begin with the interesting part. The <code>src/</code> directory contains several files. In the end each file will generate one documentation page. For example, the file <code>constants.lisp</code> contains all the constants definitions and when the documentation is generated a file <code>constants.md</code> will be created. The same occurs with the rest of the files. The most important files here are: * <code>constants.lisp</code> * <code>enums.lisp</code> * <code>functions.lisp</code> * <code>structs.lisp</code> * <code>callbacks.lisp</code></p>
<h2 id="dealing-with-constants">Dealing with constants</h2>
<p>First of all, we need to use <code>with-doc-file</code> to indicate where the documentation will be written:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>(<span class="kw">in-package</span> :my-pkg)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>(mcffi:with-doc-file (doc-file <span class="st">&quot;path/to/file.md&quot;</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>  <span class="co">;; Constants definitions here...</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>  )</span></code></pre></div>
<p>In C we can find several types of constant values. Maybe they are ’#define’d:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="pp">#define VK_LOD_CLAMP_NONE 1000.0F</span></span></code></pre></div>
<p>Or they are defined as <code>const</code> variables:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">;; Hypothetical example</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>static const uint32_t max_data_size <span class="op">=</span> <span class="dv">512</span><span class="co">;</span></span></code></pre></div>
<p>In both cases we can use the <code>def-foreign-constant</code> macro. To define the first constant <code>VK_LOD_CLAMP_NONE</code> we can do this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>(more-cffi:def-foreign-constant doc-file <span class="st">&quot;VK_LOD_CLAMP_NONE&quot;</span> vk_lod_clamp_none <span class="fl">1000.0</span>)</span></code></pre></div>
<p>The first argument is the stream where the documentation will be written. The next argument is the foreign name of the constant. We can use here a string or a symbol. If a symbol is used, the foreign name will be written in lowercase. Otherwise will be used the string. The foreign name is only used for documentation and nothing more. The next argument is the name of the constant we are defining, the name users will use. And the last argument is the value of the constant. This macro expands to a <code>defparameter</code> expression. The reason <code>defconstant</code> or <code>cffi:defcvar</code> are not used is that <code>defparameter</code> is more flexible.</p>
<h2 id="dealing-with-function-macros">Dealing with function macros</h2>
<p>The <code>#define</code> expressions can be used also to define the so-called macro functions. Here is an example:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="ch">#d</span>efine VK_MAKE_API_VERSION(variant, major, minor, patch) \</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>    ((((uint32_t)(variant)) &lt;&lt; <span class="dv">29</span>) | (((uint32_t)(major)) &lt;&lt; <span class="dv">22</span>) | (((uint32_t)(minor)) &lt;&lt; <span class="dv">12</span>) | ((uint32_t)(patch)))</span></code></pre></div>
<p>The macro functions can be seen as a very restricted version of Lisp macros. So I will use <code>def-foreign-macro</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>(more-cffi:def-foreign-macro doc-file (<span class="st">&quot;VK_MAKE_API_VERSION&quot;</span> vk_make_api_version) (variant major minor patch)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>  `(<span class="kw">logior</span> (<span class="kw">ash</span> ,variant <span class="dv">29</span>) (<span class="kw">ash</span> ,major <span class="dv">22</span>) (<span class="kw">ash</span> ,minor <span class="dv">12</span>) ,patch))</span></code></pre></div>
<p>The first argument is the stream where to write the documentation. After that we specify the foreign name and lisp name of our macro. The foreign name is only used for documentation and, as in the previous example, we can use a string or a symbol. Then we specify the macro arguments and afterwards we see the body of the macro. This expands to a <code>defmacro</code> expression.</p>
<h2 id="dealing-with-enumerations">Dealing with enumerations</h2>
<p>To define an enumeration we can use <code>def-foreign-enum</code>. Consider this C enumeration:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">enum</span> VkSamplerAddressMode {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>    VK_SAMPLER_ADDRESS_MODE_REPEAT = <span class="dv">0</span>,</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = <span class="dv">1</span>,</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = <span class="dv">2</span>,</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = <span class="dv">3</span>,</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = <span class="dv">4</span>,</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>    VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = <span class="bn">0x7FFFFFFF</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>} VkSamplerAddressMode;</span></code></pre></div>
<p>And this is the more-cffi version:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>(more-cffi:def-foreign-enum doc-file <span class="st">&quot;VkSamplerAddressMode&quot;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>  (<span class="st">&quot;VK_SAMPLER_ADDRESS_MODE_REPEAT&quot;</span> <span class="dv">0</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  (<span class="st">&quot;VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT&quot;</span> <span class="dv">1</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>  (<span class="st">&quot;VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE&quot;</span> <span class="dv">2</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>  (<span class="st">&quot;VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER&quot;</span> <span class="dv">3</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>  (<span class="st">&quot;VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE&quot;</span> <span class="dv">4</span>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  (<span class="st">&quot;VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR&quot;</span> vk_sampler_address_mode_mirror_clamp_to_edge)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>  (<span class="st">&quot;VK_SAMPLER_ADDRESS_MODE_MAX_ENUM&quot;</span> <span class="dv">2147483647</span>))</span></code></pre></div>
<p>First we indicate the stream where to write the documentation. Then we write the type of the enum. Every enum type is defined as an <code>:int</code> type. And lastly we associate each enum member with a value. The name of the members can be a string or a symbol. Note that we can use <code>vk_sampler_address_mode_mirror_clamp_to_edge</code> right after its definition. Each member is defined using <code>defparameter</code>.</p>
<h2 id="dealing-with-functions">Dealing with functions</h2>
<p>Functions are one of the most important parts in a bindings project. The C functions can accept or return pointers so we need to make some changes in order to have a proper Lisp function. I’ll show you different situations that we need to face with and I’ll tell you how to deal with them.</p>
<p>We are going to see first the next foreign function:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>VKAPI_ATTR VkResult VKAPI_CALL vkCreateInstance(</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>    <span class="dt">const</span> VkInstanceCreateInfo*                 pCreateInfo,</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>    <span class="dt">const</span> VkAllocationCallbacks*                pAllocator,</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>    VkInstance*                                 pInstance);</span></code></pre></div>
<p>Despite all the weird names, this a function that accepts three pointers and return a <code>VkResult</code> value. To define the raw binding we can use <code>defcfun</code> from CFFI but I’m using the one defined in more-cffi for convenience:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>(more-cffi:defcfun (<span class="st">&quot;vkCreateInstance&quot;</span> vkcreateinstance funcall-vkcreateinstance)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>    vkresult</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>  (pcreateinfo :pointer)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>  (pallocator :pointer)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>  (pinstance :pointer))</span></code></pre></div>
<p>This modified version of <code>defcfun</code> is almost the same as that one from CFFI. The main difference is that this version can define up to two functions. When using <code>cffi:defcfun</code> you must write the foreign name and the lisp name of the function. Here we can write two or three names. The first argument is a string of the foreign name. The second one is the lisp name of the defined function. The third one is the name of a second defined function. It is like previous one but it accept an additional first argument. It will be a pointer to the foreign function. In fact, this macro expands to <code>cffi:foreign-funcall</code> and <code>cffi:foreign-funcall-pointer</code> respectively.</p>
<p>The reason for defining the <code>funcall-</code> function is that sometimes we can receive a C function pointer from the call to another function. In that case the way that function is called is different. Luckily for us, the arguments are the same and so their translations.</p>
<p>The Lisp wrap can be achieved using <code>def-foreign-function</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>(mcffi:def-foreign-function doc-file (<span class="st">&quot;vkCreateInstance&quot;</span> create-instance funcall-create-instance) (pcreateinfo pallocator)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>  (declare-types (<span class="st">&quot;VkInstanceCreateInfo&quot;</span> <span class="st">&quot;pCreateInfo&quot;</span>) (<span class="st">&quot;VkAllocationCallbacks&quot;</span> <span class="st">&quot;pAllocator&quot;</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>                 :return (<span class="st">&quot;VkInstance&quot;</span> instance) (<span class="st">&quot;VkResult&quot;</span> result))</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>  (<span class="kw">let</span> ((pallocator-c (<span class="kw">or</span> pallocator (cffi-sys:null-pointer))))</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>    (cffi:with-foreign-object (pinstance &#39;vkinstance)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>      (<span class="kw">let</span> ((result (vkcreateinstance pcreateinfo pallocator-c pinstance)))</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>        (<span class="kw">values</span> (cffi:mem-ref pinstance &#39;vkinstance) result</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>                (<span class="kw">if</span> pallocator</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a>                    pallocator-c</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>                    <span class="kw">nil</span>))))))</span></code></pre></div>
<p>Let’s see what is happening here. The first argument is the stream where we want the documentation to be written in. Then, same as with <code>defcfun</code>, we indicate the foreign function name and the two lisp names. Afterwards we specify the arguments. Note that the original function received three arguments while now we are receiving only two. The reason is that the third argument is a C output argument. The created <code>instance</code> will be stored in the place where the pointer is pointing to. In Lisp we should return that value together with the already returned value. But before we analyze the body look at the <code>declare-types</code> expression. In it we specify the Lisp types of the arguments and the returned values. This is used only for documentation and does not have any effect on the defined functions. Afterwards, the actual body expression begins. Since we are creating a wrapper, we need to use the original foreign function in some place. You can see it inside the <code>let</code> expression. In order to call it we need to prepare the arguments. The <code>pcreateinfo</code> and <code>pallocator</code> arguments are already pointers because they are structs (more info later). However, <code>pallocator</code> can be a <code>NULL</code> pointer and Lisp haven’t that thing. We are creating the function to allow the user to pass a <code>nil</code> value. We then need to translate it to a <code>NULL</code> pointer. So we use <code>cffi:null-pointer</code> to create a <code>NULL</code> pointer if we receive a <code>nil</code> value. The last argument needs to be created. Since we are not going to need the address of the created instance, we can create the <code>pinstance</code> argument using <code>with-foreign-object</code>. Finally we prepare the values to be returned. First we return the instance obtained by dereferencing the <code>pinstance</code> pointer. Then we return the <code>result</code> value… And, are we returning a third value? We will see why below.</p>
<p>When you create something in C it is 99% certain that you will need to destroy it in some moment. The above function has its <code>destroy</code> counterpart:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a>VKAPI_ATTR <span class="dt">void</span> VKAPI_CALL vkDestroyInstance(</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>    VkInstance                                  instance,</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>    <span class="dt">const</span> VkAllocationCallbacks*                pAllocator);</span></code></pre></div>
<p>We use <code>defcfun</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>(more-cffi:defcfun (<span class="st">&quot;vkDestroyInstance&quot;</span> vkdestroyinstance funcall-vkdestroyinstance)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>    :void</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>  (instance vkinstance)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>  (pallocator :pointer))</span></code></pre></div>
<p>And finally <code>def-foreign-function</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>(more-cffi:def-foreign-function doc-file (<span class="st">&quot;vkDestroyInstance&quot;</span> destroy-instance funcall-destroy-instance) (instance pallocator)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>  (declare-types (<span class="st">&quot;VkInstance&quot;</span> instance) (<span class="st">&quot;VkAllocationCallbacks&quot;</span> <span class="st">&quot;pAllocator&quot;</span>))</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>    (<span class="kw">let</span> ((pallocator-c (<span class="kw">or</span> pallocator (cffi-sys:null-pointer))))</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>      (vkdestroyinstance instance pallocator-c)))</span></code></pre></div>
<p>Here I didn’t use the <code>:return</code> keyword inside <code>declare-type</code> because this function returns nothing. Like before, we need to prepare the arguments. The <code>pallocator</code> value can be <code>nil</code> and we should turn it into a <code>NULL</code> pointer. Finally we call the foreign function.</p>
<p>In C creating and destroying things is very common but in Lisp is not usual. For that reason more-cffi exports <code>defwith</code>. We can create <code>with-</code> macros providing only a constructor and a constructor. When using a <code>with-</code> macro we are using the constructor indirectly. In fact, the arguments we pass to <code>with-</code> are passed directly to the constructor. But what happens with the destructor? What arguments will receive? The answer is the values that the constructor returns. Note that <code>destroy-instance</code> receives an <code>instance</code> and a <code>pallocator</code>. This values must be returned by the constructor. And that’s why the constructor is returning three values!</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>(more-cffi:defwith doc-file with-instance</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>  create-instance</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>  destroy-instance</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>  :destructor-arguments (<span class="dv">0</span> <span class="dv">2</span>))</span></code></pre></div>
<p>The second argument is the name of the new <code>with-</code> macro. The third and fourth arguments are the constructor and destructor respectively. If we don’t specify anything more only the first value returned by the constructor will be received by the destructor. You can specify with <code>:destructor-arity</code> the number of values passed to the destructor. Or you can use <code>:destructor-arguments</code> to specify what arguments will be passed to the destructor. In this case <code>destroy-instance</code> will receive the first and third values returned by <code>create-instance</code> (<code>instance</code> and <code>pallocator</code>).</p>
<p>Before moving on to the next section we are going to see another example. Consider now the next foreign function:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>VKAPI_ATTR <span class="dt">void</span> VKAPI_CALL vkGetPhysicalDeviceFeatures(</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>    VkPhysicalDevice                            physicalDevice,</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>    VkPhysicalDeviceFeatures*                   pFeatures);</span></code></pre></div>
<div class="sourceCode" id="cb26"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>(more-cffi:defcfun (<span class="st">&quot;vkGetPhysicalDeviceFeatures&quot;</span> vkgetphysicaldevicefeatures funcall-vkgetphysicaldevicefeatures)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>    :void</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>  (physicaldevice vkphysicaldevice)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>  (pfeatures :pointer))</span></code></pre></div>
<p>The <code>pfeatures</code> argument is an output argument. So like we did before we should return that argument instead of receive it. A naive aproach could be doing the same as the above example:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>(more-cffi:def-foreign-function doc-file (<span class="st">&quot;vkGetPhysicalDeviceFeatures&quot;</span> get-physical-device-features funcall-get-physical-device-features) (physicaldevice)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>  (declare-types (<span class="st">&quot;VkPhysicalDevice&quot;</span> <span class="st">&quot;physicalDevice&quot;</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>                 :return (<span class="st">&quot;VkPhysicalDeviceFeatures&quot;</span> pfeatures))</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a>  (cffi:with-foreign-object (pfeatures &#39;(:struct VkPhysicaDeviceFeatures))</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a>    (vkgetphysicaldevicefeatures physicaldevice pfeatures)</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a>    (<span class="kw">values</span> pfeatures)))</span></code></pre></div>
<p>But this is not correct. We are returning a pointer that is destroyed after leaving the <code>with-foreign-object</code> expression. So, we need to explicitly allocate the object:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a>(more-cffi:def-foreign-function doc-file (<span class="st">&quot;vkGetPhysicalDeviceFeatures&quot;</span> create-get-physical-device-features funcall-get-physical-device-features) (physicaldevice)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>  (declare-types (<span class="st">&quot;VkPhysicalDevice&quot;</span> <span class="st">&quot;physicalDevice&quot;</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>                 :return (<span class="st">&quot;VkPhysicalDeviceFeatures&quot;</span> pfeatures))</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a>  (<span class="kw">let</span> ((pfeatures (cffi:foreign-alloc &#39;(:struct VkPhysicaDeviceFeatures))))</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>    (vkgetphysicaldevicefeatures physicaldevice pfeatures)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>    (<span class="kw">values</span> pfeatures)))</span></code></pre></div>
<p>See that we are using now <code>foreign-alloc</code>. But now the pointer can’t be freed. Sadly the only solution is telling to the user to free the object themself. I predicted this and I changed already the name of the function. See above that the name of the lisp function is <code>create-get-physical-device-features</code>. Let’s write the <code>destroy</code> counterpart:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>(more-cffi:def-lisp-function doc-file destroy-get-physical-device-features (pfeatures)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>  (declare-types (<span class="st">&quot;VkPhysicalDeviceFeatures&quot;</span> <span class="st">&quot;pFeatures&quot;</span>))</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>  (cffi-sys:foreign-free pfeatures))</span></code></pre></div>
<p>This function doesn’t wrap any foreign function so we need to use <code>def-lisp-function</code>. And finally if we have both <code>create</code> and <code>destroy</code> functions we should create a <code>with-</code> macro too:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a>(more-cffi:defwith doc-file with-get-physical-device-features</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>  create-get-physical-device-features</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>  destroy-get-physical-device-features)</span></code></pre></div>
<h2 id="dealing-with-callbacks">Dealing with callbacks</h2>
<p>Defining callback can be done using <code>cffi:defcallback</code>. But we will go a step further because we are going to define a callback definer. In other words, we will define a definer so the user can define their own callbacks. To do that we need to use <code>def-foreign-callback-definer</code>. Vulkan has, I think, eight different callback functions. Here is the signature of one of them:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="kw">typedef</span> VkBool32 (VKAPI_PTR *PFN_vkDebugUtilsMessengerCallbackEXT)(</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>    VkDebugUtilsMessageSeverityFlagBitsEXT           messageSeverity,</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a>    VkDebugUtilsMessageTypeFlagsEXT                  messageTypes,</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a>    <span class="dt">const</span> VkDebugUtilsMessengerCallbackDataEXT*      pCallbackData,</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a>    <span class="dt">void</span>*                                            pUserData);</span></code></pre></div>
<p>It is a difficult one because the callback can receive user data. Let’s see how the use of <code>def-foreign-callback-definer</code> looks like:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a>(more-cffi:def-foreign-callback-definer doc-file <span class="st">&quot;PFN_vkDebugUtilsMessengerCallbackEXT&quot;</span> def-debug-utils-messenger-callback-ext-callback</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>    (<span class="st">&quot;messageSeverity&quot;</span> <span class="bu">:type</span>         <span class="st">&quot;VkDebugUtilsMessageSeverityFlagBitsEXT&quot;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>                       :foreign-type vkdebugutilsmessageseverityflagbitsext)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>    (<span class="st">&quot;messageTypes&quot;</span>    <span class="bu">:type</span>         vkdebugutilsmessagetypeflagsext</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a>                       :foreign-type vkdebugutilsmessagetypeflagsext)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a>    (<span class="st">&quot;pCallbackData&quot;</span>   <span class="bu">:type</span>         <span class="st">&quot;VkDebugUtilsMessengerCallbackDataEXT&quot;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true"></a>                       :foreign-type :pointer)</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true"></a>    (<span class="st">&quot;pUserData&quot;</span>       <span class="bu">:type</span>         <span class="st">&quot;lisp object&quot;</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true"></a>                       :foreign-type :pointer</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true"></a>               <span class="bu">:create</span>       (<span class="kw">gethash</span> (cffi-sys:pointer-address puserdata) *debug-utils-messenger-callback-user-data*))</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true"></a>    (result            <span class="bu">:type</span>         <span class="kw">boolean</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true"></a>                       :foreign-type vkbool32</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true"></a>                   :return       (<span class="kw">if</span> (<span class="kw">null</span> result)</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true"></a>                                         vk_false</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true"></a>                                         vk_true)))</span></code></pre></div>
<p>Wait a moment… This doesn’t look like a callback or a function. Of course not, you are not defining a callback but a callback definer. Here we are writing how to translate the arguments from the C side to the Lisp side, and the result from the Lisp side to the C side. But let’s begin at the top. The second argument is the foreign name or type that represents the callback. It is used only for documentation. The next argument is the name of the new callback definer. Now we have a bunch of lists. Each list starts with the name of a callback parameter. After this name we need to use the different options available to tell the definer how to translate the arguments or the results. The argument <code>messageSeverity</code> is an enumeration type. Specifically, it is of type <code>vkdebugutilsmessageseverityflagbitsext</code>. We need to tell the foreign type of the arguments using the option <code>:foreign-type</code>. The option <code>:type</code> is usefull to tell the user what will be the Lisp type of the argument. This is used only for documentation. The next argument, <code>messageTypes</code> is also an enumeration so is similar to the previous one. The third argument <code>pCallbackData</code> is a struct type and it is correct to receive the raw pointer (we will see in ‘Dealing with structs’ that the user will not note that they is using pointers). The fourth argument is a pointer to C data. However, the callback should receive just Lisp data. In order to achieve this I’m using a hash table where I store the user data. More specifically, <code>pUserData</code> is a pointer but a pointer is only an integer (more or less). CFFI exports the functions <code>make-pointer</code> and <code>pointer-address</code>. They turn integers and pointers into pointers and integers respectively. In this example <code>pUserData</code> is a pointer but here the important thing is the address itself. We use the <code>:create</code> option to indicate a special translation. We use <code>pointer-addres</code> to turn the pointer into an integer that is a key in the hash table. Then the <code>gethash</code> function returns the user data. Lastly, we indicate that the callback will return a value named <code>result</code>. To indicate that this is indeed a returned value we need to use the <code>:return</code> option specifying the special translation.</p>
<p>For completion we can see where and how the user data is stored:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a>(more-cffi:def-foreign-struct doc-file <span class="st">&quot;VkDebugUtilsMessengerCreateInfoEXT&quot;</span> (debug-utils-messenger-create-info-ext)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>    (:default-create :default-get :default-set)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a>      </span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a>    ...</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a>    </span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a>    (puserdata <span class="bu">:name</span> <span class="st">&quot;pUserData&quot;</span> <span class="bu">:type</span> <span class="st">&quot;lisp object&quot;</span> :init-form <span class="kw">nil</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a>               <span class="bu">:create</span> ((puserdata-arg)</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true"></a>                        (<span class="kw">setf</span> puserdata</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true"></a>                              (<span class="kw">if</span> puserdata-arg</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true"></a>                                 (<span class="kw">prog2</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true"></a>                                     (<span class="kw">setf</span> (<span class="kw">gethash</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true"></a>                                            *debug-utils-messenger-callback-next-address*</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true"></a>                                            *debug-utils-messenger-callback-user-data*)</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true"></a>                                             puserdata-arg)</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true"></a>                                     (cffi-sys:make-pointer</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true"></a>                                      *debug-utils-messenger-callback-next-address*)</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true"></a>                                   (<span class="kw">setf</span> *debug-utils-messenger-callback-next-address*</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true"></a>                                           (<span class="op">1+</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true"></a>                                            *debug-utils-messenger-callback-next-address*)))</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true"></a>                                 (cffi-sys:null-pointer))))</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true"></a>     ...</span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true"></a></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true"></a>  )</span></code></pre></div>
<p>This is a portion of a struct definition where the user data is stored. I’m going to extract only the necessary:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a>(<span class="kw">setf</span> (<span class="kw">gethash</span> *debug-utils-messenger-callback-next-address* *debug-utils-messenger-callback-user-data*)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>      puserdata-arg)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a>(cffi-sys:make-pointer *debug-utils-messenger-callback-next-address*)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a>(<span class="kw">setf</span> *debug-utils-messenger-callback-next-address*</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a>      (<span class="op">1+</span> *debug-utils-messenger-callback-next-address*))</span></code></pre></div>
<p>The <code>*debug-utils-messenger-callback-next-address*</code> stores the next available key. It is just an increasing counter. Using this address as a key we store the user data stored in <code>puserdata-arg</code>. The <code>make-pointer</code> function is used to turn the key into a pointer and this is the value returned. But before that, the last <code>setf</code> increase the address counter.</p>
<p>The <code>def-foreign-callback-definer</code> has more power than the showed here. You can create fake arguments using the <code>:virtual</code> option. It is useful when receiven an array and its size. You can use both arguments to create a list and store it in the fake argument. The user will receive the fake argument instead of the array and its size.</p>
<h2 id="dealing-with-structs">Dealing with structs</h2>
<p>Wrapping structs consists in defining translations for each of its members. We will see a couple of examples so you can have a good understanding on how more-cffi deals with struct definitions. The macro that more-cffi exports for this is <code>def-foreign-struct</code> or <code>def-foreign-union</code> (they work the same). Consider this foreign struct already defined using CFFI:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> VkFramebufferCreateInfo {</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>    VkStructureType             sType;</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>    <span class="dt">const</span> <span class="dt">void</span>*                 pNext;</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a>    VkFramebufferCreateFlags    flags;</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a>    VkRenderPass                renderPass;</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true"></a>    <span class="dt">uint32_t</span>                    attachmentCount;</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true"></a>    <span class="dt">const</span> VkImageView*          pAttachments;</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true"></a>    <span class="dt">uint32_t</span>                    width;</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true"></a>    <span class="dt">uint32_t</span>                    height;</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true"></a>    <span class="dt">uint32_t</span>                    layers;</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true"></a>} VkFramebufferCreateInfo;</span></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a>(cffi:defcstruct vkframebuffercreateinfo</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>  (stype vkstructuretype)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>  (pnext :pointer)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>  (flags vkframebuffercreateflags)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a>  (renderpass vkrenderpass)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true"></a>  (attachmentcount :uint32)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true"></a>  (pattachments :pointer)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true"></a>  (width :uint32)</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true"></a>  (height :uint32)</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true"></a>  (layers :uint32))</span></code></pre></div>
<p>And let’s begin defining the member translations:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a>(mcffi:def-foreign-struct doc-file <span class="st">&quot;VkFramebufferCreateInfo&quot;</span> framebuffer-create-info</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>   ( <span class="co">#| Options here... |#</span> )</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a>  <span class="co">;; Member translation here...</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a>)</span></code></pre></div>
<p>As always the first argument is the stream where to write the documentation. The second argument must be a string designator with the foreign name of the struct. The third argument is the name that will be used to define the constructor, destructor, with macro, getters and setters. The fourth argument is a list of options that can modify the behaviour of <code>def-foreign-struct</code>. We will see it a bit later.</p>
<p>The <code>stype</code> member is of type <code>VkStructureType</code> that is just an enumeration (:int). We can start telling to <code>def-foreign-struct</code> that we have said member:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a>(mcffi:def-foreign-struct doc-file <span class="st">&quot;VkFramebufferCreateInfo&quot;</span> framebuffer-create-info</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a>   ()</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a>  (stype <span class="bu">:type</span> <span class="st">&quot;VkStructureType&quot;</span>))</span></code></pre></div>
<p>This macro is similar to <code>def-foreign-callback-definer</code>. For each member we specify how it is and how it must be translated using member options. The <code>:type</code> option indicates the lisp type and is used only for documentation. We can change the name of the member using <code>:name</code>. We can also use this option with a string to print the name in documentation using a wanted case:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a>(mcffi:def-foreign-struct doc-file <span class="st">&quot;VkFramebufferCreateInfo&quot;</span> framebuffer-create-info</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a>   ()</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a>  (stype <span class="bu">:name</span> <span class="st">&quot;sType&quot;</span> <span class="bu">:type</span> <span class="st">&quot;VkStructureType&quot;</span>))</span></code></pre></div>
<p>Now I’m going to use <code>:init-form</code> to specify its initial value. If not used the default init value is <code>0</code>. In Vulkan each <code>sType</code> has only one possible value describing the structure itself. In this case the value must be <code>VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a>(mcffi:def-foreign-struct doc-file <span class="st">&quot;VkFramebufferCreateInfo&quot;</span> framebuffer-create-info</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a>   ()</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true"></a>  (stype <span class="bu">:name</span> <span class="st">&quot;sType&quot;</span> <span class="bu">:type</span> <span class="st">&quot;VkStructureType&quot;</span> :init-form VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO))</span></code></pre></div>
<p>Now it is time to define the translations. Usually we will need to specify how to initialize the member in the constructor, how to destroy it, how to get it, and how to change its value. This can be done with <code>:create</code>, <code>:destroy</code>, <code>:get</code> and <code>:set</code> options. The <code>:create</code> option must have the form <code>((argument-name) &amp;rest create-exprs)</code>:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a>(mcffi:def-foreign-struct doc-file <span class="st">&quot;VkFramebufferCreateInfo&quot;</span> framebuffer-create-info</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a>   ()</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true"></a>  (stype <span class="bu">:name</span> <span class="st">&quot;sType&quot;</span> <span class="bu">:type</span> <span class="st">&quot;VkStructureType&quot;</span> :init-form VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true"></a>         <span class="bu">:create</span> ((sType-arg)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true"></a>              (<span class="kw">setf</span> sType sType-arg))))</span></code></pre></div>
<p>The member and the received value are <code>:int</code> so no special translation is needed. We just do an assignment. Note that inside <code>create-exprs</code> we can use <code>stype</code> (actually, all members are accessible). We don’t need to destroy the member because is just an <code>:int</code>. The <code>:get</code> and <code>:set</code> options are similar to <code>:create</code>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a>(mcffi:def-foreign-struct doc-file <span class="st">&quot;VkFramebufferCreateInfo&quot;</span> framebuffer-create-info</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true"></a>   ()</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true"></a>  (stype <span class="bu">:name</span> <span class="st">&quot;sType&quot;</span> <span class="bu">:type</span> <span class="st">&quot;VkStructureType&quot;</span> :init-form VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true"></a>         <span class="bu">:create</span> ((stype-arg)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true"></a>              (<span class="kw">setf</span> stype stype-arg))</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true"></a>         :get (()</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true"></a>           stype)</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true"></a>     :set ((new-value)</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true"></a>           (<span class="kw">setf</span> stype new-value))))</span></code></pre></div>
<p>The syntaxes of <code>:get</code> and <code>:set</code> are similar to <code>:create</code> but actually they can accept more arguments. The syntax of <code>:get</code> and <code>:set</code> is <code>(lambda-list &amp;rest get-or-set-exprs)</code>. The only difference is that the lambda list from <code>:set</code> must accept a first argument being non-optional and non-keyword. Having members that does not require any special translation is so common that you can get rid of these if you use the global options <code>:default-create</code>, <code>:default-get</code> and <code>:default-set</code>:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a>(mcffi:def-foreign-struct doc-file <span class="st">&quot;VkFramebufferCreateInfo&quot;</span> framebuffer-create-info</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a>   (:default-create :default-get :default-set)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true"></a>  (stype <span class="bu">:name</span> <span class="st">&quot;sType&quot;</span> <span class="bu">:type</span> <span class="st">&quot;VkStructureType&quot;</span> :init-form VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO))</span></code></pre></div>
<p>The members <code>flags</code>, <code>attachmentcount</code>, <code>width</code>, <code>height</code> and <code>layers</code> don’t require any special translation neither:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true"></a>(mcffi:def-foreign-struct doc-file <span class="st">&quot;VkFramebufferCreateInfo&quot;</span> framebuffer-create-info</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true"></a>   (:default-create :default-get :default-set)</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true"></a>  (stype <span class="bu">:name</span> <span class="st">&quot;sType&quot;</span> <span class="bu">:type</span> <span class="st">&quot;VkStructureType&quot;</span> :init-form VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO)</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true"></a>  (flags <span class="bu">:type</span> <span class="st">&quot;VkFramebufferCreateFlags&quot;</span>)</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true"></a>  (attachmentcount <span class="bu">:name</span> <span class="st">&quot;attachmentCount&quot;</span> <span class="bu">:type</span> uint32)</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true"></a>  (width <span class="bu">:type</span> uint32)</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true"></a>  (height <span class="bu">:type</span> uint32)</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true"></a>  (layers <span class="bu">:type</span> uint32))</span></code></pre></div>
<p>Now look at <code>pnext</code>. It is of type <code>:pointer</code> to <code>:void</code>. The problem with this member is that it can be a <code>NULL</code> pointer. So we need to handle when a <code>nil</code> value is received:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a>(mcffi:def-foreign-struct doc-file <span class="st">&quot;VkFramebufferCreateInfo&quot;</span> framebuffer-create-info</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true"></a>   (:default-create :default-get :default-set)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true"></a>  ...</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true"></a>  (pnext <span class="bu">:name</span> <span class="st">&quot;pNext&quot;</span> <span class="bu">:type</span> <span class="st">&quot;Vulkan object&quot;</span> :init-form <span class="kw">nil</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true"></a>         <span class="bu">:create</span> ((pnext-arg)</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true"></a>              (<span class="kw">setf</span> pnext (<span class="kw">or</span> pnext-arg (cffi:null-pointer))))</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true"></a>         :get (()</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true"></a>           (<span class="kw">if</span> (cffi:null-pointer-p pnext)</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true"></a>               <span class="kw">nil</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true"></a>           pnext))</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true"></a>         :set ((new-value)</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true"></a>           (<span class="kw">setf</span> pnext (<span class="kw">or</span> new-value (cffi:null-pointer)))))</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true"></a>  ...)</span></code></pre></div>
<p>In the <code>:create</code> expression we are turning the received value into a <code>NULL</code> pointer if it is <code>nil</code>. In the <code>:get</code> expression we are doing the reverse operation. The <code>:set</code> expression is the same as <code>:create</code>. The <code>:destroy</code> is not needed because we didn’t allocate anything.</p>
<p>The <code>renderpass</code> argument is a pointer but must be a non-<code>NULL</code> pointer, so it can be defined as the rest of primitive type members:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a>(mcffi:def-foreign-struct doc-file <span class="st">&quot;VkFramebufferCreateInfo&quot;</span> framebuffer-create-info</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true"></a>   (:default-create :default-get :default-set)</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true"></a>  ...</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true"></a>  (renderpass <span class="bu">:name</span> <span class="st">&quot;renderPass&quot;</span> <span class="bu">:type</span> <span class="st">&quot;VkRenderPass&quot;</span>)</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true"></a>  ...)</span></code></pre></div>
<p>The remaining argument <code>pattachments</code> is an array of size <code>attachmentcount</code>. In this example I will use lists as the Lisp type counterpart of C arrays. So the received value of this member is a list and we need to turn it to an array:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a>(mcffi:def-foreign-struct doc-file <span class="st">&quot;VkFramebufferCreateInfo&quot;</span> framebuffer-create-info</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true"></a>   (:default-create :default-get :default-set)</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true"></a>  ...</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true"></a>  (attachmentcount <span class="bu">:name</span> <span class="st">&quot;attachmentCount&quot;</span> <span class="bu">:type</span> uint32)</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true"></a>  (pattachments <span class="bu">:name</span> <span class="st">&quot;pAttachments&quot;</span> <span class="bu">:type</span> (<span class="kw">list</span> <span class="st">&quot;VkImageView&quot;</span>) :init-form <span class="kw">nil</span>  </span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true"></a>                <span class="bu">:create</span> ((pattachments-arg)</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true"></a>                 (<span class="kw">setf</span> pattachments (cffi:foreign-alloc &#39;VkImageView <span class="bu">:count</span> attachmentcount))  <span class="co">; VkImageView == :pointer</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true"></a>             (<span class="kw">loop</span> for i from <span class="dv">0</span> below attachmentcount</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true"></a>                   for attachment in pattachments-arg</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true"></a>                   <span class="kw">do</span> (mcffi:memcpy (cffi:mem-aptr pattachments i) attachment (cffi:foreign-type-size &#39;VkImage)))))  </span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true"></a>  ...)</span></code></pre></div>
<p>Note that we are using <code>attachmentcount</code>. But you need to be careful. This can be done because the member <code>attachmentcount</code> is defined earlier and it is initialized before <code>pattachments</code> begins its initialization. Another option could be using the <code>:create</code> option with <code>attachmentcount</code> and use its argument name. In other words, inside every <code>:create</code> expression we have access to all members and all <code>:create</code> arguments. We did an allocation so the array must be destroyed in a <code>:destroy</code> option:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a>(mcffi:def-foreign-struct doc-file <span class="st">&quot;VkFramebufferCreateInfo&quot;</span> framebuffer-create-info</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true"></a>   (:default-create :default-get :default-set)</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true"></a>  ...</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true"></a>  (attachmentcount <span class="bu">:name</span> <span class="st">&quot;attachmentCount&quot;</span> <span class="bu">:type</span> uint32)</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true"></a>  (pattachments <span class="bu">:name</span> <span class="st">&quot;pAttachments&quot;</span> <span class="bu">:type</span> (<span class="kw">list</span> <span class="st">&quot;VkImageView&quot;</span>) :init-form <span class="kw">nil</span>  </span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true"></a>                <span class="bu">:create</span> ((pattachments-arg)</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true"></a>                 (<span class="kw">setf</span> pattachments (cffi:foreign-alloc &#39;VkImageView <span class="bu">:count</span> attachmentcount)) </span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true"></a>             (<span class="kw">loop</span> for i from <span class="dv">0</span> below attachmentcount</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true"></a>                   for attachment in pattachments-arg</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true"></a>                   <span class="kw">do</span> (mcffi:memcpy (cffi:mem-aptr pattachments i) attachment (cffi:foreign-type-size &#39;VkImage))))</span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true"></a>            :destroy (cffi:foreign-free pattachments))  </span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true"></a>  ...)</span></code></pre></div>
<p>The <code>:destroy</code> option only accepts a Lisp expression. Now we can make the getter of this member:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a>(mcffi:def-foreign-struct doc-file <span class="st">&quot;VkFramebufferCreateInfo&quot;</span> framebuffer-create-info</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true"></a>   (:default-create :default-get :default-set)</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true"></a>  ...</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true"></a>  (attachmentcount <span class="bu">:name</span> <span class="st">&quot;attachmentCount&quot;</span> <span class="bu">:type</span> uint32)</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true"></a>  (pattachments <span class="bu">:name</span> <span class="st">&quot;pAttachments&quot;</span> <span class="bu">:type</span> (<span class="kw">list</span> <span class="st">&quot;VkImageView&quot;</span>) :init-form <span class="kw">nil</span>  </span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true"></a>                <span class="bu">:create</span> ((pattachments-arg)</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true"></a>                 (<span class="kw">setf</span> pattachments (cffi:foreign-alloc &#39;VkImageView <span class="bu">:count</span> attachmentcount)) </span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true"></a>             (<span class="kw">loop</span> for i from <span class="dv">0</span> below attachmentcount</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true"></a>                   for attachment in pattachments-arg</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true"></a>                   <span class="kw">do</span> (mcffi:memcpy (cffi:mem-aptr pattachments i) attachment (cffi:foreign-type-size &#39;VkImage))))</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true"></a>            :destroy (cffi:foreign-free pattachments)</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true"></a>        :get ((&amp;optional (index <span class="kw">nil</span>))</span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true"></a>              (<span class="kw">if</span> index</span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true"></a>                  (cffi:mem-aptr pattachments &#39;VkImageView index)</span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true"></a>              (<span class="kw">loop</span> for i from <span class="dv">0</span> below attachmentcount</span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true"></a>                    collect (cffi:mem-aptr pattachments &#39;VkImageView i)))))  </span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true"></a>  ...)</span></code></pre></div>
<p>Note that I used an optional argument named <code>index</code>. If the user use an index it will receive directly an element of <code>pattachments</code>. Otherwise it will receive a list. Finally we can make the setter:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a>(mcffi:def-foreign-struct doc-file <span class="st">&quot;VkFramebufferCreateInfo&quot;</span> framebuffer-create-info</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a>   (:default-create :default-get :default-set)</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true"></a>  ...</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true"></a>  (attachmentcount <span class="bu">:name</span> <span class="st">&quot;attachmentCount&quot;</span> <span class="bu">:type</span> uint32)</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true"></a>  (pattachments <span class="bu">:name</span> <span class="st">&quot;pAttachments&quot;</span> <span class="bu">:type</span> (<span class="kw">list</span> <span class="st">&quot;VkImageView&quot;</span>) :init-form <span class="kw">nil</span>  </span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true"></a>                <span class="bu">:create</span> ((pattachments-arg)</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true"></a>                 (<span class="kw">setf</span> pattachments (cffi:foreign-alloc &#39;VkImageView <span class="bu">:count</span> attachmentcount))</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true"></a>             (<span class="kw">loop</span> for i from <span class="dv">0</span> below attachmentcount</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true"></a>                   for attachment in pattachments-arg</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true"></a>                   <span class="kw">do</span> (mcffi:memcpy (cffi:mem-aptr pattachments i) attachment (cffi:foreign-type-size &#39;VkImage))))</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true"></a>            :destroy (cffi:foreign-free pattachments)</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true"></a>        :get ((&amp;optional (index <span class="kw">nil</span>))</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true"></a>              (<span class="kw">if</span> index</span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true"></a>                  (cffi:mem-aptr pattachments &#39;VkImageView index)</span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true"></a>              (<span class="kw">loop</span> for i from <span class="dv">0</span> below attachmentcount</span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true"></a>                    collect (cffi:mem-aptr pattachments &#39;VkImageView i))))</span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true"></a>        :set ((new-value &amp;optional (index <span class="kw">nil</span>))</span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true"></a>              (<span class="kw">if</span> index</span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true"></a>                  (mcffi:memcpy (cffi:mem-aptr pattachments &#39;VkImageView index) new-value (cffi:foreign-type-size &#39;VkImageView))</span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true"></a>              (<span class="kw">loop</span> for i from <span class="dv">0</span> below attachmentcount</span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true"></a>                    for attachment in new-value</span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true"></a>                <span class="kw">do</span> (mcffi:memcpy (cffi:mem-aptr pattachments &#39;VkImageView i) attachment (cffi:foreign-type-size &#39;VkImageView))))))  </span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true"></a>  ...)</span></code></pre></div>
<p>The struct can now be considered finished but it can be better. The member <code>pattachments</code> depends on <code>attachmentcount</code> and both are controlled by the user. Also, when receiving the list we can set <code>attachmentcount</code> to its size so the user doesn’t need to deal with this member. I’m going to make some changes:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a>(mcffi:def-foreign-struct doc-file <span class="st">&quot;VkFramebufferCreateInfo&quot;</span> framebuffer-create-info</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true"></a>   (:default-create :default-get :default-set)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true"></a>  ...</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true"></a>  (attachmentcount <span class="bu">:name</span> <span class="st">&quot;attachmentCount&quot;</span> <span class="bu">:type</span> uint32</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true"></a>                   <span class="bu">:create</span> <span class="kw">nil</span>)</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true"></a>  ...)</span></code></pre></div>
<p>Using a <code>nil</code> at <code>:create</code> indicates that we don’t want any translation nor any contructor argument. Same occurs when using <code>nil</code> at <code>:set</code>. We are going to handle its value from the <code>pattachments</code> translations:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a>(mcffi:def-foreign-struct doc-file <span class="st">&quot;VkFramebufferCreateInfo&quot;</span> framebuffer-create-info</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true"></a>   (:default-create :default-get :default-set)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true"></a>  ...</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true"></a>  (attachmentcount <span class="bu">:name</span> <span class="st">&quot;attachmentCount&quot;</span> <span class="bu">:type</span> uint32</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true"></a>                   <span class="bu">:create</span> <span class="kw">nil</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true"></a>           :set <span class="kw">nil</span>)</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true"></a>  (pattachments <span class="bu">:name</span> <span class="st">&quot;pAttachments&quot;</span> <span class="bu">:type</span> (<span class="kw">list</span> <span class="st">&quot;VkImageView&quot;</span>) :init-form <span class="kw">nil</span>  </span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true"></a>                <span class="bu">:create</span> ((pattachments-arg)</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true"></a>             (<span class="kw">setf</span> attachmentcount (<span class="kw">length</span> pattachments-arg))</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true"></a>                 (<span class="kw">setf</span> pattachments (cffi:foreign-alloc &#39;VkImageView <span class="bu">:count</span> attachmentcount))</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true"></a>             (<span class="kw">loop</span> for i from <span class="dv">0</span> below attachmentcount</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true"></a>                   for attachment in pattachments-arg</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true"></a>                   <span class="kw">do</span> (mcffi:memcpy (cffi:mem-aptr pattachments i) attachment (cffi:foreign-type-size &#39;VkImage))))</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true"></a>            :destroy (cffi:foreign-free pattachments)</span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true"></a>        :get ((&amp;optional (index <span class="kw">nil</span>))</span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true"></a>              (<span class="kw">if</span> index</span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true"></a>                  (cffi:mem-aptr pattachments &#39;VkImageView index)</span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true"></a>              (<span class="kw">loop</span> for i from <span class="dv">0</span> below attachmentcount</span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true"></a>                    collect (cffi:mem-aptr pattachments &#39;VkImageView i))))</span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true"></a>        :set ((new-value &amp;optional (index <span class="kw">nil</span>))</span>
<span id="cb52-21"><a href="#cb52-21" aria-hidden="true"></a>              (<span class="kw">if</span> index</span>
<span id="cb52-22"><a href="#cb52-22" aria-hidden="true"></a>                  (mcffi:memcpy (cffi:mem-aptr pattachments &#39;VkImageView index) new-value (cffi:foreign-type-size &#39;VkImageView))</span>
<span id="cb52-23"><a href="#cb52-23" aria-hidden="true"></a>              (<span class="kw">progn</span></span>
<span id="cb52-24"><a href="#cb52-24" aria-hidden="true"></a>                            (cffi:foreign-free pattachments)</span>
<span id="cb52-25"><a href="#cb52-25" aria-hidden="true"></a>                (<span class="kw">setf</span> attachmentcount (<span class="kw">length</span> new-value))</span>
<span id="cb52-26"><a href="#cb52-26" aria-hidden="true"></a>                (<span class="kw">setf</span> pattachments (cffi:foreign-alloc &#39;VkImageView <span class="bu">:count</span> attachmentcount))</span>
<span id="cb52-27"><a href="#cb52-27" aria-hidden="true"></a>                            (<span class="kw">loop</span> for i from <span class="dv">0</span> below attachmentcount</span>
<span id="cb52-28"><a href="#cb52-28" aria-hidden="true"></a>                      for attachment in new-value</span>
<span id="cb52-29"><a href="#cb52-29" aria-hidden="true"></a>                  <span class="kw">do</span> (mcffi:memcpy (cffi:mem-aptr pattachments &#39;VkImageView i) attachment (cffi:foreign-type-size &#39;VkImageView)))))))  </span>
<span id="cb52-30"><a href="#cb52-30" aria-hidden="true"></a>  ...)</span></code></pre></div>
<p>See how I set the value of <code>attachmentcount</code> in <code>:create</code> and <code>:set</code>. Finally the struct is ready to use.</p>

</body>
</html>
